Q1.
Approach 1:
def doubleL(n):
    res = []
    for i in range(n):
        res.append(i * 2)
    return res

for i in doubleL(5):
    print(i, end=' : ')

1. Function doubleL(n): This function takes an integer n as input and returns a list containing the elements [0 * 2, 1 * 2, 2 * 2, ..., (n-1) * 2].
2. Loop: The loop iterates over each element generated by doubleL(5) and prints it, separated by :, without moving to the next line.

Approach 2:
for x in [n * 2 for n in range(5)]:
    print(x, end=' : ')
1. List Comprehension: This creates a list by iterating over range(5) (which generates numbers from 0 to 4) and doubling each number.
2. Loop: The loop iterates over each element in the list generated by the list comprehension and prints it, separated by :, without moving to the next line.

Approach 3:
def doubleG(n):
    for i in range(n):
        yield i * 2

for i in doubleG(5):
    print(i, end=' : ')
    
1. Generator Function doubleG(n): This function takes an integer n as input and generates values 0 * 2, 1 * 2, 2 * 2, ..., (n-1) * 2 using yield.
2. Loop: The loop iterates over each value generated by doubleG(5) and prints it, separated by :, without moving to the next line.

Q2. 
- doubleG(n) is a generator function.
A generator function, is a special type of function in Python that allows for the lazy evaluation of a sequence of values. When called, the function doesn't execute immediately; instead, it returns a generator object, which acts as an iterator. This iterator can be iterated over to produce values on-the-fly. In the case of `doubleG(n)`, it generates a sequence of doubled values from 0 to `n-1` using the `yield` keyword, allowing for memory-efficient processing, particularly useful for large datasets or when dealing with infinite sequences. 

- Advantage of Using a Generator Function:
The advantage of using a generator function is that it generates values on-the-fly, rather than storing them all in memory at once like a list. This can be beneficial for memory efficiency, especially when dealing with large datasets. Generator functions are also more efficient when dealing with infinite sequences or when the entire sequence is not needed at once. 
