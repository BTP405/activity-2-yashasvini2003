Approach 1:
python
Copy code
def doubleL(n):
    res = []
    for i in range(n):
        res.append(i * 2)
    return res

for i in doubleL(5):
    print(i, end=' : ')
Description:

This code defines a function doubleL that takes an integer n as input.
Inside the function, it initializes an empty list res.
It then iterates through the range of numbers from 0 to n-1, multiplying each number by 2 and appending the result to the list res.
Finally, the function returns the list res.
The for loop outside the function calls doubleL(5) and iterates over the returned list, printing each element with a colon separator.
Approach 2:
python
Copy code
for x in [n * 2 for n in range(5)]:
    print(x, end=' : ')
Description:

This code uses a list comprehension to create a list by multiplying each element n from the range 0 to 4 by 2.
The resulting list is [0, 2, 4, 6, 8].
The for loop then iterates over this list, printing each element with a colon separator.
Approach 3:
python
Copy code
def doubleG(n):
    for i in range(n):
        yield i * 2

for i in doubleG(5):
    print(i, end=' : ')
Description:

This code defines a generator function doubleG that takes an integer n as input.
Inside the generator, it uses a yield statement to produce values by multiplying each number in the range 0 to n-1 by 2.
The for loop outside the generator calls doubleG(5) and iterates over the values generated, printing each element with a colon separator.
Type of Function doubleG(n):
The function doubleG(n) is a generator function. Generators in Python use the yield keyword to produce a sequence of values lazily. Unlike a regular function that creates and returns a list, a generator produces values on-the-fly and doesn't store them in memory.

Advantage of Using a Generator Function:
The advantage of using a generator function (doubleG in this case) is that it can be more memory-efficient, especially when dealing with large datasets. Instead of creating and storing an entire list in memory, a generator produces values one at a time, reducing the overall memory footprint. This is particularly beneficial when working with large or infinite sequences, as it allows for efficient memory usage and avoids unnecessary overhead.
